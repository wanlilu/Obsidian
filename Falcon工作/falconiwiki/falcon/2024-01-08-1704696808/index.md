
# 基于层和组件的程序化制作流程

fredqin(秦江)

创建，

hgyang(已离职)

修改于2022-09-06

## 背景：

*    在最初开发开放世界游戏，并且引入Houdini等程序化生成技术到游戏制作流程的过程中，遇到了一些流程上的问题：
    
    *   开放世界如何高效地多人协作编辑
        
    *   手工内容和程序化生成内容该怎样结合
        
    *   怎样保持程序化生成内容的非破坏性，能够二次编辑
        

* * *

基于这些问题，Falcon开发了**基于层和组件的程序化制作流程：**

## **分层：**

![](1704696808-3968557c1f1681de98c4024ad3afd906.png)

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

对于开放世界的制作，引擎的做法是将大地图以网格的方式来切分，将每个地块独立保存为一个关卡文件。

而一个关卡文件同时只能有一个人编辑，在协作的过程中限制会非常多。这样的流程并不灵活，并不适合去开发 开放世界类型的游戏。

Falcon做的第一件事就是把引擎中 地图的分块 改为分层。通过类似于图层的方式来分割地图的内容，再通过实时合成来混合所有层的内容。

通过这样分层的方式，项目在协作时，能够根据空间来分工，比如按不同的生态去分工，或者按不同的区域来分工。

也能够按内容来分工，比如地形、植被，道路等等。同时也能对流程进行划分，比如关卡设计层、程序化层、和手工细化层。

![](1704696808-3aa5e02d3f6ef3ccdede846b26401657.png)

从类型上Falcon定义了3种层：

第一种是程序化层，承载我们的程序化生成组件和所生成的数据。我们通过调整里面程序化组件的堆栈顺序来控制程序化生成的顺序。

第二种是手工层。用来承载手工编辑内容，和传统的地形一致，可以在上面编辑所有数据。包括地形，权重图，植被，模型等等。

第三种是背景层，可以让我们在制作过程中随时调整地图的精度、大小、高度范围、材质等等。

![](1704696808-fe7f47d23bd8ce9fcd2a2c2810371074.png)

每一个层对应一个关卡文件，每个层可以调整大小，有Mask控制合成范围。

每个层能承载全套数据，层和层之间采用覆盖的、自下而上的混合方式。

![](1704696808-c0cd7f9613f2bbe466f1759e34bcea00.png)

用来管理和合成这些层的模块叫Stack，通过层的划分和组合来控制协作的流程。

Falcon也通过这样的方式来控制手工制作内容和程序化生成内容的结合。

![](1704696808-866db21f5ad72f0156d5b2addfb9ab6c.png)

这套分层框架的灵感来自于PS，其中的一些概念和逻辑与PS非常相似，对于用户来说更容易理解和使用

例如Stack中的手工层相当于PS中的普通图层，程序化层相当于一组调整图层，而背景层就相当于PS中的画布。

另外堆栈式的结构相对于节点式的流程控制，更易于使用。在流程复杂度高的时候还能保持清晰的流程和结构。

这些层的行为和PS也相似，在制作过程中能够调整层的大小、位置、绘制遮罩。还可以对层进行打组、塌陷等操作。

![](1704696808-440e94836b11f718678e962280095ceb.png)

分工协作的另一个重点是文件本身，在每个层单独保存为一个关卡的时候，如果还需要通过统一的文件来记录这些层的结构和顺序，那还是没法做到灵活的协作。

所以Falcon开发了去中心化的层索引模式。不需要有专门的文件来记录层的结构，通过对比独立关卡文件的时间戳，来获取最新的层排序列表。

![](1704696808-a7cb382a6d2773500c85c23ad4f477c1.png)

在对整套流程进行了大幅修改之后，还会面临一个问题：

怎样兼容已有的工具链，比如项目已有的优化工具、测试工具等等。

Falcon的解决方案是通过导出流程将编辑场景和实际的游戏场景隔离开。

Falcon会根据项目的配置，通过自动流水线的形式把编辑关卡导出成游戏需要的场景规格。

在导出完成后就和传统流程里的场景规格是一致的，其他工具链都可以正常使用。

同时，还会在导出时自动去执行对于场景本身的后处理，例如HLOD的生成，资产的合并优化，地形的切割等等。Falcon也支持根据配置去 同时导出不同版本的游戏关卡。

另外Falcon会把离线工具的最终Bake步骤放到导出时自动执行，这样在编辑关卡时可以保持随时修改的能力。

以上就是Falcon对于多人协作、手工内容与程序化内容结合的解决方案。

## 组件

对于程序化生成流程的控制，我们通过组件堆栈的方式来解决。

![](1704696808-95f1942cc061ec2683820edc9c17ba59.gif)

![](1704696808-e8624665f6f337d50b5bcabbbdadde57.gif)

![](1704696808-503bf0a4d5f48256430093b616f82759.gif)

![](1704696808-84278c440af8e9bf7942dec700393031.gif)

我们有这样的一些基础组件，例如不同的Noise，用来给地形添加细节或者塑造基础地形，也有很多滤镜，例如扰动、梯田等等，

也有将模型投射成地形高度或者Mask的组件，也可以结合引擎中的建模工具或者使用其他组件的数据来修改地形。

还有模拟类的组件，例如侵蚀、积雪、水流等等。

```plain
<video width="1000" controls>
  <source src="http://falcon-gz01.woa.com/view/videos/stack/Stack_%E5%BF%AB%E9%80%9F%E5%85%B3%E5%8D%A1%E7%94%9F%E6%88%90.mp4" type="video/mp4">
Tags of your video... which won't be displayed.
</video>
```

在使用过程中，通过这些组件的堆叠组合，来控制程序化生成的流程。

视频里通过不断添加各种程序化的组件，来制作出我们需要的效果。

先添加Noise组件来生成基础的地形结构，再通过侵蚀组件来模拟地形的侵蚀效果，然后再通过mask组件生成地形的材质。

也有曲线组件来构建道路，实时修改地形高度和材质。通过GPU的植被组件来生成场景中的植被，并且实时调整他们的分布效果。

这些组件按堆栈的顺序来执行，通过全局数据来保持他们之间的关联。

我们可以添加任意数量的组件，或者调整他们的顺序，也可以在不同的层之间去移动和复制这些组件。

非破坏性流程

通过这种分层和组件的方式，我们将所有编辑过程中的数据都保留下来，这样我们可以根据需要，随时对流程中的任意数据进行调整。

```plain
<video width="1000" controls>
  <source src="http://falcon-gz01.woa.com/view/videos/%E9%9D%9E%E7%A0%B4%E5%9D%8F%E6%80%A7%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B.mp4" type="video/mp4">
Tags of your video... which won't be displayed.
</video>
```

如视频展示，制作过程中数据都以组件的方式保留，在这里我回到第一步，去调整地图中用来控制山峰的基础模型，在调整完成后重新执行后续的组件，就能得到修改后的结果。我们通过这样的方式来做到非破坏性的流程。

优而赞之，手有余香

成为第一个点赞的人

*   本文引用
*   本文被引用

Falcon

*   ![](1704696808-48f34ae457aeafc603ab0a403f103594.svg)290
    
*   ![](1704696808-0b95f0082c86623bb3ccf41eddc04c8b.png)66
    
*   ![](1704696808-fd7976f7b401fb858c859dda738b7af1.png)0
    

![](1704696808-58e5fa504b5449b7a89a07130def4d77.png)添加标签

![](1704696808-325ac912a48e528af8ab64d72cca36b5.svg)

发表评论，抢沙发...

![](1704696808-d56c24c81b5e5f02b023f9382e1ca21d.svg)
